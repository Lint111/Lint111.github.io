<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Getting Started with Vulkan - Lior Yaari</title>
    <link rel="stylesheet" href="../styles.css">
    <style>
        .post-container {
            max-width: 800px;
            margin: 0 auto;
            padding: 2rem;
        }

        .post-header {
            margin-bottom: 2rem;
        }

        .post-title {
            font-size: 2.5rem;
            margin-bottom: 1rem;
        }

        .post-meta {
            color: #888;
            margin-bottom: 2rem;
        }

        .post-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-bottom: 2rem;
        }

        .post-tag {
            background: #2a2a2a;
            color: #4a90e2;
            padding: 0.5rem 1rem;
            border-radius: 20px;
            font-size: 0.875rem;
        }

        .post-content {
            line-height: 1.8;
            color: #ccc;
        }

        .post-content h2 {
            color: #4a90e2;
            margin-top: 2rem;
            margin-bottom: 1rem;
        }

        .post-content h3 {
            color: #4a90e2;
            margin-top: 1.5rem;
            margin-bottom: 0.75rem;
        }

        .post-content code {
            background: #2a2a2a;
            padding: 0.2rem 0.5rem;
            border-radius: 4px;
            color: #50e3c2;
        }

        .post-content pre {
            background: #2a2a2a;
            padding: 1rem;
            border-radius: 8px;
            overflow-x: auto;
            margin: 1rem 0;
        }

        .post-content pre code {
            background: none;
            padding: 0;
        }

        .post-content ul, .post-content ol {
            margin-left: 2rem;
            margin-bottom: 1rem;
        }

        .post-content blockquote {
            border-left: 4px solid #4a90e2;
            padding-left: 1rem;
            margin: 1rem 0;
            color: #888;
        }

        .back-link {
            display: inline-block;
            margin-bottom: 2rem;
            color: #4a90e2;
            text-decoration: none;
            font-size: 1.1rem;
        }

        .back-link:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body>
    <nav>
        <ul>
            <li><a href="../index.html">Home</a></li>
            <li><a href="../blog.html">Blog</a></li>
            <li><a href="../index.html#projects">Projects</a></li>
            <li><a href="../lior-yaari-resume.pdf" target="_blank">Resume</a></li>
        </ul>
    </nav>

    <div class="post-container">
        <a href="../blog.html" class="back-link">← Back to Blog</a>

        <article>
            <header class="post-header">
                <h1 class="post-title">Getting Started with Vulkan: A Graphics Programmer's Journey</h1>
                <div class="post-meta">
                    By Lior Yaari • November 12, 2025 • 8 min read
                </div>
                <div class="post-tags">
                    <span class="post-tag">Vulkan</span>
                    <span class="post-tag">Graphics Programming</span>
                    <span class="post-tag">Game Engine</span>
                    <span class="post-tag">C++</span>
                </div>
            </header>

            <div class="post-content">
                <h2>Introduction</h2>
                <p>
                    Learning Vulkan has been one of the most challenging yet rewarding experiences in my game development journey. 
                    Unlike higher-level APIs like OpenGL or DirectX 11, Vulkan forces you to understand graphics programming at a 
                    much deeper level. In this post, I'll share my experience and key takeaways from building a custom game engine 
                    with Vulkan.
                </p>

                <h2>Why Vulkan?</h2>
                <p>When I started this project, I had several goals:</p>
                <ul>
                    <li><strong>Performance</strong>: Access to low-level GPU control for maximum optimization</li>
                    <li><strong>Learning</strong>: Deep understanding of modern graphics pipelines</li>
                    <li><strong>Portability</strong>: Cross-platform support (Windows, Linux, Android)</li>
                    <li><strong>Future-proofing</strong>: Industry-standard API that's actively developed</li>
                </ul>

                <h2>The Learning Curve</h2>
                
                <h3>Initial Challenges</h3>
                <p>
                    The first thing that struck me about Vulkan was the sheer amount of boilerplate code required. Setting up a 
                    simple triangle took over 1000 lines of code! Here are some of the biggest hurdles:
                </p>
                <ol>
                    <li><strong>Verbose Setup</strong>: Everything from instance creation to swap chain management requires explicit configuration</li>
                    <li><strong>Memory Management</strong>: Manual allocation and synchronization of GPU memory</li>
                    <li><strong>Synchronization</strong>: Understanding semaphores, fences, and pipeline barriers</li>
                    <li><strong>Validation Layers</strong>: Debugging is crucial and requires proper validation layer setup</li>
                </ol>

                <h3>Key Concepts to Master</h3>
                <pre><code>// Example: Creating a Vulkan Instance
VkApplicationInfo appInfo{};
appInfo.sType = VK_STRUCTURE_TYPE_APPLICATION_INFO;
appInfo.pApplicationName = "VIXEN Engine";
appInfo.applicationVersion = VK_MAKE_VERSION(1, 0, 0);
appInfo.pEngineName = "VIXEN";
appInfo.engineVersion = VK_MAKE_VERSION(1, 0, 0);
appInfo.apiVersion = VK_API_VERSION_1_3;</code></pre>

                <p>The most important concepts to understand are:</p>
                <ul>
                    <li><strong>Pipeline State Objects</strong>: All rendering state compiled ahead of time</li>
                    <li><strong>Command Buffers</strong>: Recording and submitting GPU commands</li>
                    <li><strong>Descriptor Sets</strong>: Binding resources (textures, buffers) to shaders</li>
                    <li><strong>Render Passes</strong>: Organizing rendering operations efficiently</li>
                </ul>

                <h2>Performance Insights</h2>
                <p>
                    One of the biggest revelations was understanding that Vulkan's complexity pays off in performance. 
                    By properly batching draw calls and using instancing, I achieved:
                </p>
                <ul>
                    <li><strong>60% reduction</strong> in CPU overhead compared to my previous OpenGL implementation</li>
                    <li><strong>Consistent 144+ FPS</strong> on mid-range hardware</li>
                    <li><strong>Better memory utilization</strong> through manual control</li>
                </ul>

                <h2>Common Pitfalls</h2>
                
                <h3>1. Improper Synchronization</h3>
                <pre><code>// BAD: No synchronization
vkQueueSubmit(queue, 1, &submitInfo, VK_NULL_HANDLE);
vkQueueSubmit(queue, 1, &submitInfo2, VK_NULL_HANDLE);

// GOOD: Use fences
vkQueueSubmit(queue, 1, &submitInfo, fence);
vkWaitForFences(device, 1, &fence, VK_TRUE, UINT64_MAX);</code></pre>

                <h3>2. Memory Leaks</h3>
                <p>Always pair creation with destruction. Use RAII wrappers when possible.</p>

                <h3>3. Validation Layers in Release</h3>
                <p>Don't forget to disable validation layers in release builds - they add significant overhead!</p>

                <h2>Resources That Helped</h2>
                <ul>
                    <li><strong>Vulkan Tutorial</strong>: The best starting point (vulkan-tutorial.com)</li>
                    <li><strong>Vulkan Programming Guide</strong>: Comprehensive reference</li>
                    <li><strong>Sascha Willems' Examples</strong>: Excellent practical examples</li>
                    <li><strong>Khronos Vulkan Samples</strong>: Official code samples</li>
                </ul>

                <h2>Next Steps</h2>
                <p>Now that I have a basic engine running, my next goals are:</p>
                <ul>
                    <li>Implement deferred rendering</li>
                    <li>Add ray tracing support (VK_KHR_ray_tracing)</li>
                    <li>Optimize for mobile (Vulkan on Android)</li>
                    <li>Create a scene graph system</li>
                </ul>

                <h2>Conclusion</h2>
                <p>
                    Learning Vulkan is not for the faint of heart, but the control and performance it offers make it worthwhile. 
                    If you're considering learning Vulkan, my advice is:
                </p>
                <ol>
                    <li><strong>Start with the basics</strong>: Follow Vulkan Tutorial step by step</li>
                    <li><strong>Use validation layers</strong>: They'll save you hours of debugging</li>
                    <li><strong>Study examples</strong>: Learn from existing implementations</li>
                    <li><strong>Be patient</strong>: It takes time, but understanding clicks eventually</li>
                </ol>

                <p>
                    The journey from drawing a triangle to rendering complex scenes is long, but incredibly educational. 
                    Every line of code teaches you something about how GPUs actually work.
                </p>

                <hr style="margin: 2rem 0; border: none; border-top: 1px solid #444;">

                <p style="text-align: center; color: #888;">
                    <em>Have questions about Vulkan or game engine development? Feel free to reach out!</em>
                </p>
            </div>
        </article>

        <a href="../blog.html" class="back-link" style="margin-top: 3rem; display: inline-block;">← Back to Blog</a>
    </div>
</body>
</html>
